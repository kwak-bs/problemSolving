# 케빈 베이컨의 6단계 법칙
## BOJ_10026번_실버1
- BFS 이용.

## 전역 변수

`int map[][]` = 관계를 나타내는 이중 배열

`boolean visit[]` = 방문을 나타내는 배열

`int total[]` = 각 점마다 케빈 베이컨의 수를 저장하는 배열

`int y` =  입력, map의 크기

`int x` = 입력, 관계 수



## 함수

### void main

map의 크기와 관계 수를 입력받습니다. 

모든 전역변수 혹은 min, answer값을 초기화 해줍니다.

map을 입력 받고, 출발점과 도착점을 인자로 `bfs`를 호출합니다.

호출할 때마다 visit배열을 초기화하고 호출한 결과 값(count)를 total배열에 저장합니다.

최소 값을 비교하여 최소 값이 되는 인덱스를 저장합니다. 

### void bfs (int from, int to)

인자로 출발점과 도착점을 받습니다. 

출발점을 기준으로 이어져있는 간선들을 `q`에 넣습니다. 

초기에 집어넣어진 간선 들은 `count`가 1입니다. (각각의 간선들은 가중치가 1이기 때문.)

`q`를 돌면서 간선에 해당하는 정점들을 가져옵니다. 

가져온 정점이 도착점과 같으면 `count`를 리턴하고 아니면 다시 반복문을 통해 

가져온 정점에 해당하는 간선들의 정점을 `q`에 넣습니다. 

`while(qSize-- > 0) `을 통해 한 정점에 대한 간선 별로 `count` 값을 증가시킬 수 있습니다.